import { UALError, User, UALErrorType, Authenticator } from 'universal-authenticator-library';
import AnchorLink from 'anchor-link';
import { JsonRpc } from 'eosjs';
import { PackedTransaction, SignedTransaction, FetchProvider, APIClient } from '@greymass/eosio';
import AnchorLinkBrowserTransport from 'anchor-link-browser-transport';

class UALAnchorError extends UALError {
  constructor(message, type, cause) {
    let m = message;
    let e = new Error(message);
    if (cause) {
      if (cause.details && cause.details[0]) {
        m = cause.details[0].message;
        e = new Error(cause.details[0].message);
      }
      e.json = {
        code: 500,
        error: cause.error,
        message: "Internal Service Error"
      };
    }
    super(m, type, e, Name);
  }
}

class AnchorUser extends User {
  constructor(rpc, client, identity) {
    super();
    this.accountName = "";
    this.requestPermission = "";
    const { session } = identity;
    this.accountName = String(session.auth.actor);
    this.chainId = String(session.chainId);
    if (identity.signatures) {
      [this.signerProof] = identity.signatures;
    }
    if (identity.signerKey) {
      this.signerKey = identity.signerKey;
    }
    if (identity.resolvedTransaction) {
      this.signerRequest = identity.transaction;
    }
    this.requestPermission = String(session.auth.permission);
    this.session = session;
    this.client = client;
    this.rpc = rpc;
  }
  objectify(data) {
    return JSON.parse(JSON.stringify(data));
  }
  async signTransaction(transaction, options) {
    try {
      let completedTransaction;
      if (options.expireSeconds && !transaction.expiration) {
        const info = await this.client.v1.chain.get_info();
        const tx = {
          ...transaction,
          ...info.getTransactionHeader(options.expireSeconds)
        };
        completedTransaction = await this.session.transact(tx, options);
      } else {
        completedTransaction = await this.session.transact(transaction, options);
      }
      const wasBroadcast = options.broadcast !== false;
      const serializedTransaction = PackedTransaction.fromSigned(
        SignedTransaction.from(completedTransaction.transaction)
      );
      return this.returnEosjsTransaction(wasBroadcast, {
        ...completedTransaction,
        transaction_id: completedTransaction.payload.tx,
        serializedTransaction: serializedTransaction.packed_trx.array,
        signatures: this.objectify(completedTransaction.signatures)
      });
    } catch (e) {
      const message = "Unable to sign transaction";
      const type = UALErrorType.Signing;
      const cause = e;
      throw new UALAnchorError(message, type, cause);
    }
  }
  async signArbitrary(publicKey, data, _) {
    throw new UALAnchorError(
      `Anchor does not currently support signArbitrary(${publicKey}, ${data})`,
      UALErrorType.Unsupported,
      null
    );
  }
  async verifyKeyOwnership(challenge) {
    throw new UALAnchorError(
      `Anchor does not currently support verifyKeyOwnership(${challenge})`,
      UALErrorType.Unsupported,
      null
    );
  }
  async getAccountName() {
    return this.accountName;
  }
  async getChainId() {
    return this.chainId;
  }
  async getKeys() {
    try {
      const keys = await this.signatureProvider.getAvailableKeys(this.requestPermission);
      return keys;
    } catch (error) {
      const message = `Unable to getKeys for account ${this.accountName}.
        Please make sure your wallet is running.`;
      const type = UALErrorType.DataRequest;
      const cause = error;
      throw new UALAnchorError(message, type, cause);
    }
  }
  async isAccountValid() {
    try {
      const account = this.client && await this.client.v1.chain.get_account(this.accountName);
      const actualKeys = this.extractAccountKeys(account);
      const authorizationKeys = await this.getKeys();
      return actualKeys.filter((key) => {
        return authorizationKeys.indexOf(key) !== -1;
      }).length > 0;
    } catch (e) {
      if (e.constructor.name === "UALAnchorError") {
        throw e;
      }
      const message = `Account validation failed for account ${this.accountName}.`;
      const type = UALErrorType.Validation;
      const cause = e;
      throw new UALAnchorError(message, type, cause);
    }
  }
  extractAccountKeys(account) {
    const keySubsets = account.permissions.map(
      (permission) => permission.required_auth.keys.map((key) => key.key)
    );
    let keys = [];
    for (const keySubset of keySubsets) {
      keys = keys.concat(keySubset);
    }
    return keys;
  }
}

const AnchorLogo = `data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS40NCwgMCwgMCwgMS40NCwgLTguNTAxOTI1LCAtNTcuMDc0NTcpIiBzdHlsZT0iIj4KICAgIDx0aXRsZT5XaGl0ZTwvdGl0bGU+CiAgICA8Y2lyY2xlIGN4PSI5NC43OTMiIGN5PSIxMjguNTI0IiByPSI4MCIgZmlsbD0iI0ZCRkRGRiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0gOTQuNzk5IDc4LjUyNCBDIDk3LjA5OCA3OC41MjQgOTkuMTk1IDc5LjgzNyAxMDAuMTk4IDgxLjkwNiBMIDEyNC4yMDQgMTMxLjQwNiBMIDEyNC43NDYgMTMyLjUyNCBMIDExMS40MDkgMTMyLjUyNCBMIDEwNy41MyAxMjQuNTI0IEwgODIuMDY5IDEyNC41MjQgTCA3OC4xODkgMTMyLjUyNCBMIDY0Ljg1MyAxMzIuNTI0IEwgNjUuMzk1IDEzMS40MDYgTCA4OS40MDEgODEuOTA2IEMgOTAuNDA0IDc5LjgzNyA5Mi41MDEgNzguNTI0IDk0Ljc5OSA3OC41MjQgWiBNIDg2LjkxOSAxMTQuNTI0IEwgMTAyLjY4IDExNC41MjQgTCA5NC43OTkgOTguMjc0IEwgODYuOTE5IDExNC41MjQgWiBNIDExMi43OTMgMTQ5LjUyNCBMIDEyNC43OTggMTQ5LjUyNCBDIDEyNC40MzcgMTY1LjY3NiAxMTEuMDY3IDE3OC41MjQgOTQuNzk5IDE3OC41MjQgQyA3OC41MzIgMTc4LjUyNCA2NS4xNjIgMTY1LjY3NiA2NC44MDEgMTQ5LjUyNCBMIDc2LjgwNiAxNDkuNTI0IEMgNzcuMDg3IDE1Ni44NzggODEuOTc0IDE2My4xNTUgODguNzkzIDE2NS41MiBMIDg4Ljc5MyAxNDEuNTI0IEMgODguNzkzIDEzOC4yMSA5MS40OCAxMzUuNTI0IDk0Ljc5MyAxMzUuNTI0IEMgOTguMTA3IDEzNS41MjQgMTAwLjc5MyAxMzguMjEgMTAwLjc5MyAxNDEuNTI0IEwgMTAwLjc5MyAxNjUuNTI0IEMgMTA3LjYyIDE2My4xNjIgMTEyLjUxMSAxNTYuODgzIDExMi43OTMgMTQ5LjUyNCBaIiBmaWxsPSIjMzY1MEEyIi8+CiAgPC9nPgo8L3N2Zz4=`;
const Name = "Anchor";
class Anchor extends Authenticator {
  constructor(chains, options) {
    super(chains);
    this.users = [];
    this.service = "https://cb.anchor.link";
    this.disableGreymassFuel = false;
    this.requestStatus = false;
    this.fuelReferrer = "teamgreymass";
    this.verifyProofs = false;
    this.isInitFinished = false;
    this.chainId = chains[0].chainId;
    this.users = [];
    const [chain] = chains;
    const [rpc] = chain.rpcEndpoints;
    if (options && options.appName) {
      this.appName = options.appName;
    } else {
      throw new UALAnchorError(
        "ual-anchor requires the appName property to be set on the `options` argument during initialization.",
        UALErrorType.Initialization,
        null
      );
    }
    if (options && options.rpc) {
      this.rpc = options.rpc;
    } else {
      this.rpc = new JsonRpc(`${rpc.protocol}://${rpc.host}:${rpc.port}`);
    }
    if (options && options.client) {
      this.client = options.client;
    } else {
      const provider = new FetchProvider(`${rpc.protocol}://${rpc.host}:${rpc.port}`);
      this.client = new APIClient({ provider });
    }
    if (options.service) {
      this.service = options.service;
    }
    if (options && options.disableGreymassFuel) {
      this.disableGreymassFuel = options.disableGreymassFuel;
    }
    if (options && options.requestStatus) {
      this.requestStatus = options.requestStatus;
    }
    if (options && options.fuelReferrer) {
      this.fuelReferrer = options.fuelReferrer;
    }
    if (options && options.verifyProofs) {
      this.verifyProofs = options.verifyProofs;
    }
  }
  async init() {
    this.isInitFinished = false;
    this.link = new AnchorLink({
      chains: [
        {
          chainId: this.chainId,
          nodeUrl: this.client
        }
      ],
      service: this.service,
      transport: new AnchorLinkBrowserTransport({
        requestStatus: this.requestStatus,
        disableGreymassFuel: this.disableGreymassFuel,
        fuelReferrer: this.fuelReferrer
      }),
      verifyProofs: this.verifyProofs
    });
    const session = await this.link.restoreSession(this.appName);
    if (session) {
      this.users = [new AnchorUser(this.rpc, this.client, { session })];
    }
    this.isInitFinished = true;
  }
  reset() {
    this.users = [];
  }
  isErrored() {
    return false;
  }
  getOnboardingLink() {
    return "https://github.com/greymass/anchor/";
  }
  getError() {
    return null;
  }
  isLoading() {
    return !this.isInitFinished;
  }
  getName() {
    return "anchor";
  }
  getStyle() {
    return {
      icon: AnchorLogo,
      text: Name,
      textColor: "white",
      background: "#3650A2"
    };
  }
  shouldRender() {
    return true;
  }
  shouldAutoLogin() {
    return this.users.length > 0;
  }
  async shouldRequestAccountName() {
    return false;
  }
  async login() {
    if (this.chains.length > 1) {
      throw new UALAnchorError(
        "UAL-Anchor does not yet support providing multiple chains to UAL. Please initialize the UAL provider with a single chain.",
        UALErrorType.Unsupported,
        null
      );
    }
    try {
      if (this.users.length === 0) {
        const identity = await this.link.login(this.appName);
        this.users = [new AnchorUser(this.rpc, this.client, identity)];
      }
    } catch (e) {
      throw new UALAnchorError(e.message, UALErrorType.Login, e);
    }
    return this.users;
  }
  async logout() {
    if (this.users.length) {
      const [user] = this.users;
      const {
        session: { auth }
      } = user;
      await this.link.removeSession(this.appName, auth, this.chainId);
    }
    this.reset();
  }
  requiresGetKeyConfirmation() {
    return false;
  }
}

export { Anchor, AnchorUser, Name, UALAnchorError };
