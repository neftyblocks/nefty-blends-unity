"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const eosjs_numeric_1 = require("eosjs/dist/eosjs-numeric");
class AuthorityProvider {
    constructor(rpc) {
        this.rpc = rpc;
    }
    getRequiredKeys(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transaction } = args;
            // Iterate over the actions and authorizations
            transaction.actions.forEach((action, ti) => {
                action.authorization.forEach((auth, ai) => {
                    // If the authorization matches the expected cosigner
                    // then remove it from the transaction while checking
                    // for what public keys are required
                    if (auth.actor === "boost.wax" && auth.permission === "paybw") {
                        delete transaction.actions[ti];
                    }
                });
            });
            // the rpc below should be an already configured JsonRPC client from eosjs
            return eosjs_numeric_1.convertLegacyPublicKeys((yield this.rpc.fetch("/v1/chain/get_required_keys", {
                available_keys: args.availableKeys,
                transaction
            })).required_keys);
        });
    }
}
exports.AuthorityProvider = AuthorityProvider;
